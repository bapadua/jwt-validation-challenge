name: EKS Infrastructure & API Deployment

on:
  push:
    paths:
      - 'backend-challenge/**'
      - 'jwt-validation-lib/**'
      - 'terraform/eks/**'
      - '.github/workflows/eks-deploy.yml'
      - 'pom.xml'
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente para deploy (dev/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      destroy:
        description: 'Destruir infraestrutura ap√≥s testes?'
        required: false
        type: boolean
        default: false

env:
  JAVA_VERSION: '21'
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: '1.6.0'

jobs:
  prepare:
    name: Preparar Deploy
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Definir ambiente
      id: set-env
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        else
          ENVIRONMENT="dev" # Ambiente padr√£o para push
        fi
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "üöÄ Deploy para ambiente: $ENVIRONMENT"
  
  build:
    name: Build API
    runs-on: ubuntu-latest
    needs: prepare
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven
    
    - name: Build Multi-Module Project
      run: |
        # Mostra a estrutura do projeto
        echo "üìÅ Estrutura do projeto:"
        ls -la
        
        # Executa o build na raiz do projeto para compilar todos os m√≥dulos
        echo "üî® Iniciando build multi-m√≥dulo..."
        mvn clean install -DskipTests
        
        # Verifica se o JAR foi gerado corretamente
        echo "üì¶ Verificando backend-challenge:"
        ls -la backend-challenge/target/
        
        # Verifica se a biblioteca jwt-validation-lib foi compilada
        echo "üîç Verificando se jwt-validation-lib foi compilada:"
        ls -la jwt-validation-lib/target/ || echo "‚ùå jwt-validation-lib n√£o foi compilada"
        
        # Verifica se o JAR da biblioteca existe (usando find para wildcards)
        if find jwt-validation-lib/target/ -name "jwt-validation-lib-*.jar" -type f | grep -q .; then
          echo "‚úÖ jwt-validation-lib compilada com sucesso"
          find jwt-validation-lib/target/ -name "jwt-validation-lib-*.jar" -type f
        else
          echo "‚ùå jwt-validation-lib n√£o foi encontrada"
          echo "üìÅ Conte√∫do do diret√≥rio jwt-validation-lib/target/:"
          ls -la jwt-validation-lib/target/ || echo "Diret√≥rio n√£o existe"
          exit 1
        fi
    
    - name: Upload API artifact
      uses: actions/upload-artifact@v4
      with:
        name: api-package
        path: backend-challenge/target/backend-challenge-*.jar
        retention-days: 1
  
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [prepare, build]
    environment: ${{ needs.prepare.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: Initialize AWS Backend
      run: |
        chmod +x terraform/eks/init-aws.sh
        cd terraform/eks
        ../eks/init-aws.sh
    
    - name: Terraform Init
      run: |
        cd terraform/eks
        terraform init
    
    - name: Check and Clear Terraform Locks
      run: |
        cd terraform/eks
        echo "üîç Verificando locks ativos do Terraform..."
        
        # Verifica se a tabela DynamoDB existe
        if ! aws dynamodb describe-table --table-name jwt-api-terraform-locks &>/dev/null; then
          echo "‚ö†Ô∏è Tabela jwt-api-terraform-locks n√£o existe. Criando..."
          aws dynamodb create-table \
            --table-name jwt-api-terraform-locks \
            --attribute-definitions AttributeName=LockID,AttributeType=S \
            --key-schema AttributeName=LockID,KeyType=HASH \
            --billing-mode PAY_PER_REQUEST \
            --region ${{ env.AWS_REGION }} || echo "Falha ao criar tabela"
        fi
        
        # Aguarda um pouco para garantir que a tabela est√° dispon√≠vel
        sleep 5
        
        # Verifica se h√° locks ativos com retry
        LOCK_COUNT=0
        for i in {1..3}; do
          LOCK_COUNT=$(aws dynamodb scan \
            --table-name jwt-api-terraform-locks \
            --select COUNT \
            --query 'Count' \
            --output text 2>/dev/null || echo "0")
          
          if [ "$LOCK_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è Encontrados $LOCK_COUNT locks ativos. Removendo..."
            break
          else
            echo "‚úÖ Nenhum lock ativo encontrado (tentativa $i/3)"
            if [ $i -lt 3 ]; then
              sleep 2
            fi
          fi
        done
        
        if [ "$LOCK_COUNT" -gt 0 ]; then
          # Lista locks ativos
          echo "üìã Locks ativos encontrados:"
          aws dynamodb scan \
            --table-name jwt-api-terraform-locks \
            --select ALL_ATTRIBUTES \
            --output table || echo "N√£o foi poss√≠vel listar locks"
          
          # Remove todos os locks (for√ßa unlock)
          echo "üîì Removendo locks..."
          LOCK_IDS=$(aws dynamodb scan \
            --table-name jwt-api-terraform-locks \
            --query 'Items[].LockID.S' \
            --output text 2>/dev/null || echo "")
          
          if [ -n "$LOCK_IDS" ]; then
            echo "$LOCK_IDS" | tr '\t' '\n' | while read -r lock_id; do
              if [ -n "$lock_id" ]; then
                echo "üîì Removendo lock: $lock_id"
                aws dynamodb delete-item \
                  --table-name jwt-api-terraform-locks \
                  --key "{\"LockID\":{\"S\":\"$lock_id\"}}" && echo "‚úÖ Lock removido: $lock_id" || echo "‚ùå Falha ao remover lock: $lock_id"
              fi
            done
          fi
          
          # Verifica se ainda h√° locks
          sleep 2
          REMAINING_LOCKS=$(aws dynamodb scan \
            --table-name jwt-api-terraform-locks \
            --select COUNT \
            --query 'Count' \
            --output text 2>/dev/null || echo "0")
          
          if [ "$REMAINING_LOCKS" -eq 0 ]; then
            echo "‚úÖ Todos os locks foram removidos com sucesso"
          else
            echo "‚ö†Ô∏è Ainda restam $REMAINING_LOCKS locks. Tentando remo√ß√£o for√ßada..."
            # Tenta remover o lock espec√≠fico mencionado no erro
            aws dynamodb delete-item \
              --table-name jwt-api-terraform-locks \
              --key '{"LockID":{"S":"jwt-api-terraform-state/eks/terraform.tfstate"}}' && echo "‚úÖ Lock espec√≠fico removido" || echo "‚ùå Falha ao remover lock espec√≠fico"
          fi
        else
          echo "‚úÖ Nenhum lock ativo encontrado"
        fi
    
    - name: Terraform Plan
      continue-on-error: true
      run: |
        cd terraform/eks
        terraform plan -var="environment=${{ needs.prepare.outputs.environment }}" \
                      -var="grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin123Change' }}" \
                      -out=tfplan
        
        # Verifica se o plan foi gerado com sucesso
        if [ ! -f "tfplan" ]; then
          echo "‚ùå Arquivo tfplan n√£o foi gerado. Falha no plan."
          exit 1
        fi
        
        # Verifica se o arquivo tem conte√∫do v√°lido
        PLAN_SIZE=$(stat -c%s tfplan 2>/dev/null || stat -f%z tfplan 2>/dev/null || echo "0")
        if [ "$PLAN_SIZE" -eq 0 ]; then
          echo "‚ùå Arquivo tfplan est√° vazio. Falha no plan."
          exit 1
        fi
        
        echo "‚úÖ Plan gerado com sucesso. Tamanho: $PLAN_SIZE bytes"
    
    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: terraform/eks/tfplan
        retention-days: 1
  
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [prepare, terraform-plan]
    environment: ${{ needs.prepare.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: Terraform Init
      run: |
        cd terraform/eks
        terraform init
    
    - name: Check and Clear Terraform Locks (Apply)
      run: |
        cd terraform/eks
        echo "üîç Verificando locks antes do apply..."
        
        # Verifica se h√° locks ativos
        LOCK_COUNT=$(aws dynamodb scan \
          --table-name jwt-api-terraform-locks \
          --select COUNT \
          --query 'Count' \
          --output text 2>/dev/null || echo "0")
        
        if [ "$LOCK_COUNT" -gt 0 ]; then
          echo "‚ö†Ô∏è Encontrados $LOCK_COUNT locks ativos antes do apply. Removendo..."
          
          # Remove o lock espec√≠fico mencionado no erro
          aws dynamodb delete-item \
            --table-name jwt-api-terraform-locks \
            --key '{"LockID":{"S":"jwt-api-terraform-state/eks/terraform.tfstate"}}' && echo "‚úÖ Lock removido" || echo "‚ùå Falha ao remover lock"
        else
          echo "‚úÖ Nenhum lock ativo encontrado antes do apply"
        fi
    
    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan
        path: terraform/eks
    
    - name: Verify Terraform Plan
      run: |
        cd terraform/eks
        echo "üîç Verificando arquivo tfplan..."
        
        if [ ! -f "tfplan" ]; then
          echo "‚ùå Arquivo tfplan n√£o encontrado ap√≥s download"
          exit 1
        fi
        
        PLAN_SIZE=$(stat -c%s tfplan 2>/dev/null || stat -f%z tfplan 2>/dev/null || echo "0")
        if [ "$PLAN_SIZE" -eq 0 ]; then
          echo "‚ùå Arquivo tfplan est√° vazio ap√≥s download"
          exit 1
        fi
        
        echo "‚úÖ Arquivo tfplan v√°lido. Tamanho: $PLAN_SIZE bytes"
        
        # Tenta validar o plan
        terraform show tfplan > /dev/null 2>&1
        if [ $? -ne 0 ]; then
          echo "‚ùå Arquivo tfplan est√° corrompido ou inv√°lido"
          exit 1
        fi
        
        echo "‚úÖ Plan validado com sucesso"
    
    - name: Terraform Apply
      run: |
        cd terraform/eks
        terraform apply -auto-approve tfplan
    
    - name: Capture Outputs
      id: terraform_output
      run: |
        cd terraform/eks
        echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
        echo "jwt_api_url=$(terraform output -raw jwt_api_url)" >> $GITHUB_OUTPUT
        echo "grafana_url=$(terraform output -raw grafana_url)" >> $GITHUB_OUTPUT
        echo "grafana_admin_user=$(terraform output -raw grafana_admin_user)" >> $GITHUB_OUTPUT
    
    - name: Setup kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ steps.terraform_output.outputs.cluster_name }} --region ${{ env.AWS_REGION }}

    - name: Verify Deployment Status
      run: |
        echo "‚è≥ Aguardando todos os pods ficarem dispon√≠veis..."
        
        # Verifica namespace da API JWT
        echo "üîç Verificando namespace jwt-api..."
        kubectl get pods -n jwt-api
        
        # Verifica namespace de monitoramento
        echo "üîç Verificando namespace de monitoramento..."
        kubectl get pods -n monitoring
    
    - name: Test API
      run: |
        echo "üß™ Testando API JWT (pode demorar at√© 5 minutos para ficar dispon√≠vel)..."
        
        # Obt√©m o endpoint real do ALB
        echo "üîç Obtendo IP/HOST do ALB..."
        INGRESS_HOST=$(kubectl get ingress -n jwt-api -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')
        
        if [ -z "$INGRESS_HOST" ]; then
          echo "‚ö†Ô∏è Ingress ainda n√£o possui IP/hostname atribu√≠do. Aguardando..."
          sleep 60
          INGRESS_HOST=$(kubectl get ingress -n jwt-api -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')
        fi
        
        if [ -n "$INGRESS_HOST" ]; then
          echo "üîó Endpoint encontrado: $INGRESS_HOST"
          
          # Tenta acessar a API (pode ainda n√£o estar pronta)
          echo "üß™ Testando com um JWT v√°lido..."
          curl -X POST -H "Content-Type: application/json" \
            -d '{"token": "eyJhbGciOiJIUzI1NiJ9.eyJSb2xlIjoiQWRtaW4iLCJTZWVkIjoiNzg0MSIsIk5hbWUiOiJUb25pbmhvIEFyYXVqbyJ9.QY05sIjtrcJnP533kQNk8QXcaleJ1Q01jWY_ZzIZuAg"}' \
            -w "\nüìä Status: %{http_code}\n" \
            http://$INGRESS_HOST/validate || echo "‚ùå Falha na conex√£o (pode ser normal durante o provisionamento)"
        else
          echo "‚ö†Ô∏è N√£o foi poss√≠vel obter o endpoint do ALB ainda. A API pode levar alguns minutos para ficar dispon√≠vel."
        fi
    
    - name: Deployment Summary
      run: |
        echo "## üöÄ Deploy conclu√≠do!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîó URLs de Acesso" >> $GITHUB_STEP_SUMMARY
        echo "- **API JWT:** ${{ steps.terraform_output.outputs.jwt_api_url }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Grafana:** ${{ steps.terraform_output.outputs.grafana_url }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üîê Credenciais Grafana" >> $GITHUB_STEP_SUMMARY
        echo "- **Usu√°rio:** ${{ steps.terraform_output.outputs.grafana_admin_user }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Senha:** [Definida nos secrets]" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### üí° Observa√ß√µes" >> $GITHUB_STEP_SUMMARY
        echo "- Os endpoints podem demorar alguns minutos para ficarem dispon√≠veis ap√≥s a implanta√ß√£o" >> $GITHUB_STEP_SUMMARY
        echo "- Para acesso via nome de host, configure os DNSs conforme necess√°rio" >> $GITHUB_STEP_SUMMARY
        
  cleanup:
    name: Cleanup (Condicional)
    runs-on: ubuntu-latest
    needs: [prepare, terraform-apply]
    environment: ${{ needs.prepare.outputs.environment }}
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.destroy == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: Terraform Init
      run: |
        cd terraform/eks
        terraform init
    
    - name: Terraform Destroy
      run: |
        cd terraform/eks
        terraform destroy -auto-approve \
         -var="environment=${{ needs.prepare.outputs.environment }}" \
         -var="grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin123Change' }}"
    
    - name: Cleanup Summary
      run: |
        echo "## üßπ Limpeza conclu√≠da!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Toda a infraestrutura foi removida com sucesso." >> $GITHUB_STEP_SUMMARY 