name: EKS Infrastructure & API Deployment

on:
  push:
    paths:
      - 'backend-challenge/**'
      - 'jwt-validation-lib/**'
      - 'terraform/eks/**'
      - '.github/workflows/eks-deploy.yml'
      - 'pom.xml'
    branches: [ main ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Ambiente para deploy (dev/prod)'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - prod
      destroy:
        description: 'Destruir infraestrutura apÃ³s testes?'
        required: false
        type: boolean
        default: false

env:
  JAVA_VERSION: '21'
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: '1.6.0'

jobs:
  prepare:
    name: Preparar Deploy
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Definir ambiente
      id: set-env
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        else
          ENVIRONMENT="dev" # Ambiente padrÃ£o para push
        fi
        echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
        echo "ðŸš€ Deploy para ambiente: $ENVIRONMENT"
  
  build:
    name: Build API
    runs-on: ubuntu-latest
    needs: prepare
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: ${{ env.JAVA_VERSION }}
        distribution: 'temurin'
        cache: maven
    
    - name: Build Multi-Module Project
      run: |
        # Mostra a estrutura do projeto
        echo "ðŸ“ Estrutura do projeto:"
        ls -la
        
        # Executa o build na raiz do projeto para compilar todos os mÃ³dulos
        echo "ðŸ”¨ Iniciando build multi-mÃ³dulo..."
        mvn clean install -DskipTests
        
        # Verifica se o JAR foi gerado corretamente
        echo "ðŸ“¦ Verificando backend-challenge:"
        ls -la backend-challenge/target/
        
        # Verifica se a biblioteca jwt-validation-lib foi compilada
        echo "ðŸ” Verificando se jwt-validation-lib foi compilada:"
        ls -la jwt-validation-lib/target/ || echo "âŒ jwt-validation-lib nÃ£o foi compilada"
        
        # Verifica se o JAR da biblioteca existe (usando find para wildcards)
        if find jwt-validation-lib/target/ -name "jwt-validation-lib-*.jar" -type f | grep -q .; then
          echo "âœ… jwt-validation-lib compilada com sucesso"
          find jwt-validation-lib/target/ -name "jwt-validation-lib-*.jar" -type f
        else
          echo "âŒ jwt-validation-lib nÃ£o foi encontrada"
          echo "ðŸ“ ConteÃºdo do diretÃ³rio jwt-validation-lib/target/:"
          ls -la jwt-validation-lib/target/ || echo "DiretÃ³rio nÃ£o existe"
          exit 1
        fi
    
    - name: Upload API artifact
      uses: actions/upload-artifact@v4
      with:
        name: api-package
        path: backend-challenge/target/backend-challenge-*.jar
        retention-days: 1
  
  terraform-plan:
    name: Terraform Plan
    runs-on: ubuntu-latest
    needs: [prepare, build]
    environment: ${{ needs.prepare.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: Initialize AWS Backend
      run: |
        chmod +x terraform/eks/init-aws.sh
        cd terraform/eks
        ../eks/init-aws.sh
    
    - name: Terraform Init
      run: |
        cd terraform/eks
        terraform init
    
    - name: Check and Clear Terraform Locks
      run: |
        cd terraform/eks
        echo "ðŸ” Verificando locks ativos do Terraform..."
        
        # Verifica se hÃ¡ locks ativos
        LOCK_COUNT=$(aws dynamodb scan \
          --table-name jwt-api-terraform-locks \
          --select COUNT \
          --query 'Count' \
          --output text 2>/dev/null || echo "0")
        
        if [ "$LOCK_COUNT" -gt 0 ]; then
          echo "âš ï¸ Encontrados $LOCK_COUNT locks ativos. Removendo..."
          
          # Lista locks ativos
          aws dynamodb scan \
            --table-name jwt-api-terraform-locks \
            --select ALL_ATTRIBUTES \
            --output table || echo "NÃ£o foi possÃ­vel listar locks"
          
          # Remove todos os locks (forÃ§a unlock)
          aws dynamodb scan \
            --table-name jwt-api-terraform-locks \
            --query 'Items[].LockID.S' \
            --output text | tr '\t' '\n' | while read -r lock_id; do
            if [ -n "$lock_id" ]; then
              echo "ðŸ”“ Removendo lock: $lock_id"
              aws dynamodb delete-item \
                --table-name jwt-api-terraform-locks \
                --key "{\"LockID\":{\"S\":\"$lock_id\"}}" || echo "Falha ao remover lock: $lock_id"
            fi
          done
          
          echo "âœ… Locks removidos"
        else
          echo "âœ… Nenhum lock ativo encontrado"
        fi
    
    - name: Terraform Plan
      run: |
        cd terraform/eks
        terraform plan -var="environment=${{ needs.prepare.outputs.environment }}" \
                      -var="grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin123Change' }}" \
                      -out=tfplan
      
    - name: Upload Terraform Plan
      uses: actions/upload-artifact@v4
      with:
        name: terraform-plan
        path: terraform/eks/tfplan
        retention-days: 1
  
  terraform-apply:
    name: Terraform Apply
    runs-on: ubuntu-latest
    needs: [prepare, terraform-plan]
    environment: ${{ needs.prepare.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: Terraform Init
      run: |
        cd terraform/eks
        terraform init
    
    - name: Download Terraform Plan
      uses: actions/download-artifact@v4
      with:
        name: terraform-plan
        path: terraform/eks
    
    - name: Terraform Apply
      run: |
        cd terraform/eks
        terraform apply -auto-approve tfplan
    
    - name: Capture Outputs
      id: terraform_output
      run: |
        cd terraform/eks
        echo "cluster_name=$(terraform output -raw cluster_name)" >> $GITHUB_OUTPUT
        echo "jwt_api_url=$(terraform output -raw jwt_api_url)" >> $GITHUB_OUTPUT
        echo "grafana_url=$(terraform output -raw grafana_url)" >> $GITHUB_OUTPUT
        echo "grafana_admin_user=$(terraform output -raw grafana_admin_user)" >> $GITHUB_OUTPUT
    
    - name: Setup kubeconfig
      run: |
        aws eks update-kubeconfig --name ${{ steps.terraform_output.outputs.cluster_name }} --region ${{ env.AWS_REGION }}

    - name: Verify Deployment Status
      run: |
        echo "â³ Aguardando todos os pods ficarem disponÃ­veis..."
        
        # Verifica namespace da API JWT
        echo "ðŸ” Verificando namespace jwt-api..."
        kubectl get pods -n jwt-api
        
        # Verifica namespace de monitoramento
        echo "ðŸ” Verificando namespace de monitoramento..."
        kubectl get pods -n monitoring
    
    - name: Test API
      run: |
        echo "ðŸ§ª Testando API JWT (pode demorar atÃ© 5 minutos para ficar disponÃ­vel)..."
        
        # ObtÃ©m o endpoint real do ALB
        echo "ðŸ” Obtendo IP/HOST do ALB..."
        INGRESS_HOST=$(kubectl get ingress -n jwt-api -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')
        
        if [ -z "$INGRESS_HOST" ]; then
          echo "âš ï¸ Ingress ainda nÃ£o possui IP/hostname atribuÃ­do. Aguardando..."
          sleep 60
          INGRESS_HOST=$(kubectl get ingress -n jwt-api -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}')
        fi
        
        if [ -n "$INGRESS_HOST" ]; then
          echo "ðŸ”— Endpoint encontrado: $INGRESS_HOST"
          
          # Tenta acessar a API (pode ainda nÃ£o estar pronta)
          echo "ðŸ§ª Testando com um JWT vÃ¡lido..."
          curl -X POST -H "Content-Type: application/json" \
            -d '{"token": "eyJhbGciOiJIUzI1NiJ9.eyJSb2xlIjoiQWRtaW4iLCJTZWVkIjoiNzg0MSIsIk5hbWUiOiJUb25pbmhvIEFyYXVqbyJ9.QY05sIjtrcJnP533kQNk8QXcaleJ1Q01jWY_ZzIZuAg"}' \
            -w "\nðŸ“Š Status: %{http_code}\n" \
            http://$INGRESS_HOST/validate || echo "âŒ Falha na conexÃ£o (pode ser normal durante o provisionamento)"
        else
          echo "âš ï¸ NÃ£o foi possÃ­vel obter o endpoint do ALB ainda. A API pode levar alguns minutos para ficar disponÃ­vel."
        fi
    
    - name: Deployment Summary
      run: |
        echo "## ðŸš€ Deploy concluÃ­do!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ”— URLs de Acesso" >> $GITHUB_STEP_SUMMARY
        echo "- **API JWT:** ${{ steps.terraform_output.outputs.jwt_api_url }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Grafana:** ${{ steps.terraform_output.outputs.grafana_url }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ” Credenciais Grafana" >> $GITHUB_STEP_SUMMARY
        echo "- **UsuÃ¡rio:** ${{ steps.terraform_output.outputs.grafana_admin_user }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Senha:** [Definida nos secrets]" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ’¡ ObservaÃ§Ãµes" >> $GITHUB_STEP_SUMMARY
        echo "- Os endpoints podem demorar alguns minutos para ficarem disponÃ­veis apÃ³s a implantaÃ§Ã£o" >> $GITHUB_STEP_SUMMARY
        echo "- Para acesso via nome de host, configure os DNSs conforme necessÃ¡rio" >> $GITHUB_STEP_SUMMARY
        
  cleanup:
    name: Cleanup (Condicional)
    runs-on: ubuntu-latest
    needs: [prepare, terraform-apply]
    environment: ${{ needs.prepare.outputs.environment }}
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.destroy == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Setup Terraform
      uses: hashicorp/setup-terraform@v3
      with:
        terraform_version: ${{ env.TERRAFORM_VERSION }}
    
    - name: Terraform Init
      run: |
        cd terraform/eks
        terraform init
    
    - name: Terraform Destroy
      run: |
        cd terraform/eks
        terraform destroy -auto-approve \
         -var="environment=${{ needs.prepare.outputs.environment }}" \
         -var="grafana_admin_password=${{ secrets.GRAFANA_ADMIN_PASSWORD || 'admin123Change' }}"
    
    - name: Cleanup Summary
      run: |
        echo "## ðŸ§¹ Limpeza concluÃ­da!" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Toda a infraestrutura foi removida com sucesso." >> $GITHUB_STEP_SUMMARY 