name: Service Monitoring

on:
  schedule:
    # Executar a cada 5 minutos
    - cron: '*/5 * * * *'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to monitor'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  AWS_REGION: us-east-1

jobs:
  monitor-lambda:
    name: Monitor Lambda Functions
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Health check Lambda Production
      id: lambda-health
      run: |
        echo "üîç Checking Lambda function health..."
        
        # Test function invocation
        RESPONSE=$(aws lambda invoke \
          --function-name ${{ secrets.LAMBDA_FUNCTION_NAME_PROD }}:PROD \
          --payload '{"healthCheck": true}' \
          --cli-read-timeout 30 \
          response.json)
          
        STATUS_CODE=$(echo $RESPONSE | jq -r '.StatusCode')
        
        if [ "$STATUS_CODE" -eq 200 ]; then
          echo "‚úÖ Lambda function is healthy"
          echo "healthy=true" >> $GITHUB_OUTPUT
        else
          echo "‚ùå Lambda function is unhealthy - Status: $STATUS_CODE"
          echo "healthy=false" >> $GITHUB_OUTPUT
          cat response.json
        fi
        
    - name: Check Lambda metrics
      run: |
        echo "üìä Checking Lambda CloudWatch metrics..."
        
        # Get error rate from last 5 minutes
        ERROR_RATE=$(aws cloudwatch get-metric-statistics \
          --namespace AWS/Lambda \
          --metric-name Errors \
          --dimensions Name=FunctionName,Value=${{ secrets.LAMBDA_FUNCTION_NAME_PROD }} \
          --statistics Sum \
          --start-time $(date -u -d '5 minutes ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --query 'Datapoints[0].Sum' \
          --output text)
          
        # Get duration from last 5 minutes
        DURATION=$(aws cloudwatch get-metric-statistics \
          --namespace AWS/Lambda \
          --metric-name Duration \
          --dimensions Name=FunctionName,Value=${{ secrets.LAMBDA_FUNCTION_NAME_PROD }} \
          --statistics Average \
          --start-time $(date -u -d '5 minutes ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 300 \
          --query 'Datapoints[0].Average' \
          --output text)
          
        echo "Error rate (last 5 min): ${ERROR_RATE:-0}"
        echo "Average duration (last 5 min): ${DURATION:-0} ms"
        
        # Alert if error rate > 0
        if [ "${ERROR_RATE:-0}" != "0" ] && [ "${ERROR_RATE}" != "None" ]; then
          echo "üö® Lambda error rate is elevated: $ERROR_RATE"
          exit 1
        fi
        
    - name: Send alert if Lambda unhealthy
      if: steps.lambda-health.outputs.healthy == 'false'
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'üö® Lambda function ${{ secrets.LAMBDA_FUNCTION_NAME_PROD }} is unhealthy!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  monitor-backend-api:
    name: Monitor Backend API
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Health check Backend API
      id: api-health
      run: |
        echo "üîç Checking Backend API health..."
        
        # Test health endpoint
        RESPONSE=$(curl -s -w "%{http_code}" -o response.txt \
          --max-time 30 \
          ${{ secrets.BACKEND_API_URL }}/actuator/health)
          
        HTTP_CODE="${RESPONSE: -3}"
        
        if [ "$HTTP_CODE" -eq 200 ]; then
          echo "‚úÖ Backend API is healthy"
          echo "healthy=true" >> $GITHUB_OUTPUT
          echo "Response: $(cat response.txt)"
        else
          echo "‚ùå Backend API is unhealthy - HTTP: $HTTP_CODE"
          echo "healthy=false" >> $GITHUB_OUTPUT
          echo "Response: $(cat response.txt)"
        fi
        
    - name: Test JWT validation endpoint
      run: |
        echo "üîç Testing JWT validation functionality..."
        
        # Test with valid JWT
        VALID_RESPONSE=$(curl -s -w "%{http_code}" -o valid_response.txt \
          --max-time 30 \
          -H "Authorization: Bearer ${{ secrets.TEST_VALID_JWT }}" \
          ${{ secrets.BACKEND_API_URL }}/api/jwt/validate)
          
        VALID_HTTP_CODE="${VALID_RESPONSE: -3}"
        
        # Test with invalid JWT
        INVALID_RESPONSE=$(curl -s -w "%{http_code}" -o invalid_response.txt \
          --max-time 30 \
          -H "Authorization: Bearer invalid.jwt.token" \
          ${{ secrets.BACKEND_API_URL }}/api/jwt/validate)
          
        INVALID_HTTP_CODE="${INVALID_RESPONSE: -3}"
        
        echo "Valid JWT test - HTTP: $VALID_HTTP_CODE, Response: $(cat valid_response.txt)"
        echo "Invalid JWT test - HTTP: $INVALID_HTTP_CODE, Response: $(cat invalid_response.txt)"
        
        # Validate responses
        if [ "$VALID_HTTP_CODE" -eq 200 ] && [ "$INVALID_HTTP_CODE" -eq 401 ]; then
          echo "‚úÖ JWT validation is working correctly"
        else
          echo "‚ùå JWT validation is not working correctly"
          exit 1
        fi
        
    - name: Test database connectivity
      run: |
        echo "üîç Testing database connectivity..."
        
        RESPONSE=$(curl -s -w "%{http_code}" -o db_response.txt \
          --max-time 30 \
          ${{ secrets.BACKEND_API_URL }}/actuator/health/db)
          
        HTTP_CODE="${RESPONSE: -3}"
        
        if [ "$HTTP_CODE" -eq 200 ]; then
          echo "‚úÖ Database connectivity is healthy"
          echo "Response: $(cat db_response.txt)"
        else
          echo "‚ùå Database connectivity issues - HTTP: $HTTP_CODE"
          echo "Response: $(cat db_response.txt)"
          exit 1
        fi
        
    - name: Send alert if API unhealthy
      if: steps.api-health.outputs.healthy == 'false'
      uses: 8398a7/action-slack@v3
      with:
        status: failure
        text: 'üö® Backend API ${{ secrets.BACKEND_API_URL }} is unhealthy!'
      env:
        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  performance-metrics:
    name: Collect Performance Metrics
    runs-on: ubuntu-latest
    needs: [monitor-lambda, monitor-backend-api]
    if: always() && github.ref == 'refs/heads/main'
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
        
    - name: Collect performance metrics
      run: |
        echo "üìà Collecting performance metrics..."
        
        # Lambda metrics
        echo "## Lambda Metrics (Last hour)"
        aws cloudwatch get-metric-statistics \
          --namespace AWS/Lambda \
          --metric-name Duration \
          --dimensions Name=FunctionName,Value=${{ secrets.LAMBDA_FUNCTION_NAME_PROD }} \
          --statistics Average,Maximum \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 3600 \
          --query 'Datapoints[0]' \
          --output table
          
        aws cloudwatch get-metric-statistics \
          --namespace AWS/Lambda \
          --metric-name Invocations \
          --dimensions Name=FunctionName,Value=${{ secrets.LAMBDA_FUNCTION_NAME_PROD }} \
          --statistics Sum \
          --start-time $(date -u -d '1 hour ago' +%Y-%m-%dT%H:%M:%S) \
          --end-time $(date -u +%Y-%m-%dT%H:%M:%S) \
          --period 3600 \
          --query 'Datapoints[0].Sum' \
          --output text
          
        echo "‚úÖ Metrics collection completed"
        
    - name: Store metrics in CloudWatch
      run: |
        echo "üíæ Storing custom metrics..."
        
        # Store monitoring run status
        aws cloudwatch put-metric-data \
          --namespace "JWT/Monitoring" \
          --metric-data MetricName=MonitoringRun,Value=1,Unit=Count,Timestamp=$(date -u +%Y-%m-%dT%H:%M:%S)
          
        echo "‚úÖ Custom metrics stored" 